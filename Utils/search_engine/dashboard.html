<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Knowledge Base</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- CHARGEMENT DES DONNÉES -->
    <script src="kb_data.js" onerror="console.log('Mode Démo: Lancez indexer.py pour vos vraies données')"></script>

    <style>
        body { background-color: #0f172a; color: #e2e8f0; overflow: hidden; }
        .canvas-container { cursor: grab; }
        .canvas-container:active { cursor: grabbing; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Styles des lignes de connexion */
        .node-line { 
            stroke: #334155; 
            stroke-width: 2px; 
            fill: none; 
            transition: all 0.5s ease; 
        }
        
        /* Ligne active (Chemin bleu) */
        .node-line.active { 
            stroke: #3b82f6; /* blue-500 */
            stroke-width: 3px; 
            stroke-dasharray: 10;
            animation: dash 30s linear infinite; /* Animation lente du flux */
            filter: drop-shadow(0 0 4px rgba(59, 130, 246, 0.6));
            opacity: 1 !important;
            z-index: 10;
        }

        @keyframes dash {
            to { stroke-dashoffset: -1000; }
        }
        
        .glass-panel {
            background: rgba(30, 41, 59, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Indicateur visuel pendant la frappe (Glow jaune) */
        .live-match {
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.5) !important;
            border-color: #eab308 !important; 
            transform: scale(1.02);
            z-index: 50;
        }

        /* Indicateur de résultat final (Glow bleu fort) */
        .final-match {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.6) !important;
            border-color: #60a5fa !important;
            background-color: rgba(30, 58, 138, 0.6) !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- MOCK DATA ---
        const MOCK_DATA = {
            name: "Root",
            type: "folder",
            path: ".",
            children: [
                {
                    name: "Courses",
                    type: "folder",
                    children: [
                        { 
                            name: "Protocols", 
                            type: "folder", 
                            children: [
                                { name: "SSH", type: "folder", children: [{name: "footprinting.md", type: "file", content: "ssh nmap port 22"}] },
                                { name: "SMB", type: "folder", children: [{name: "readme.md", type: "file", content: "smb port 445"}] }
                            ] 
                        },
                        { 
                            name: "Web", 
                            type: "folder", 
                            children: [
                                { name: "WordPress", type: "folder", children: [{name: "footprinting.md", type: "file", content: "wpscan wp-login"}] }
                            ] 
                        }
                    ]
                },
                {
                    name: "Labs",
                    type: "folder",
                    children: [
                        { name: "HTB_A_FOOTPRINTING", type: "folder", children: [] }
                    ]
                }
            ]
        };

        const TreeCanvas = () => {
            const [data, setData] = useState(window.KB_DATA || MOCK_DATA);
            const [searchTerms, setSearchTerms] = useState([]);
            const [inputValue, setInputValue] = useState("");
            const [transform, setTransform] = useState({ x: 50, y: 50, scale: 1 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [selectedFile, setSelectedFile] = useState(null);
            
            // Gestion de l'ouverture/fermeture des dossiers
            const [collapsedPaths, setCollapsedPaths] = useState(new Set());
            
            // Résultats de recherche validés (Chemin bleu)
            const [highlightedPaths, setHighlightedPaths] = useState(new Set());

            // --- GESTION DU PLIAGE ---
            const toggleCollapse = (e, path) => {
                e.stopPropagation();
                const newSet = new Set(collapsedPaths);
                if (newSet.has(path)) newSet.delete(path);
                else newSet.add(path);
                setCollapsedPaths(newSet);
            };

            // --- GESTION DE LA RECHERCHE ---
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && inputValue.trim()) {
                    setSearchTerms([...searchTerms, inputValue.trim().toLowerCase()]);
                    setInputValue("");
                }
                if (e.key === 'Backspace' && !inputValue && searchTerms.length > 0) {
                    setSearchTerms(searchTerms.slice(0, -1));
                }
            };

            const removeTag = (index) => {
                setSearchTerms(searchTerms.filter((_, i) => i !== index));
            };

            // --- MOTEUR DE RECHERCHE ---
            useEffect(() => {
                if (searchTerms.length === 0) {
                    setHighlightedPaths(new Set());
                    return;
                }

                const matches = new Set();
                
                const searchNode = (node, parentPath = "") => {
                    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
                    let isDirectMatch = false;

                    // 1. Recherche par nom (Fonctionne pour Dossiers ET Fichiers)
                    const nameMatches = searchTerms.every(term => node.name.toLowerCase().includes(term));
                    if (nameMatches) isDirectMatch = true;

                    // 2. Recherche par contenu (Fichiers uniquement)
                    if (node.type === 'file' && node.content) {
                        const contentMatches = searchTerms.every(term => 
                            node.name.toLowerCase().includes(term) || node.content.includes(term)
                        );
                        if (contentMatches) isDirectMatch = true;
                    }

                    // Récursion vers les enfants
                    let childMatched = false;
                    if (node.children) {
                        node.children.forEach(child => {
                            if (searchNode(child, currentPath)) childMatched = true;
                        });
                    }

                    // LOGIQUE DU CHEMIN BLEU :
                    // On ajoute ce noeud au chemin si :
                    // A) C'est le noeud recherché (isDirectMatch)
                    // B) Il contient un enfant recherché (childMatched) -> pour tracer la ligne VERS l'enfant
                    if (isDirectMatch || childMatched) {
                        matches.add(currentPath);
                        return true;
                    }
                    return false;
                };

                searchNode(data);
                setHighlightedPaths(matches);
            }, [searchTerms, data]);

            // --- GESTION DU CANVAS ---
            const handleWheel = (e) => {
                e.preventDefault();
                const scaleAmount = -e.deltaY * 0.001;
                const newScale = Math.min(Math.max(transform.scale + scaleAmount, 0.2), 3);
                setTransform(prev => ({ ...prev, scale: newScale }));
            };

            const handleMouseDown = (e) => {
                if (e.target.closest('.interactive-node')) return;
                setIsDragging(true);
                setDragStart({ x: e.clientX - transform.x, y: e.clientY - transform.y });
            };

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                setTransform(prev => ({
                    ...prev,
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                }));
            };

            const handleMouseUp = () => setIsDragging(false);

            // --- RENDU RÉCURSIF ---
            const renderTree = (node, x, y, level, parentPath = "") => {
                const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
                
                // État de recherche
                const isHighlighted = searchTerms.length > 0 && highlightedPaths.has(currentPath);
                const isDimmed = searchTerms.length > 0 && !isHighlighted;
                
                // Live Match (pendant la frappe)
                const isLiveMatch = inputValue.trim() !== "" && node.name.toLowerCase().includes(inputValue.toLowerCase());

                // Ouverture forcée si sur le chemin d'un résultat
                const forceExpand = searchTerms.length > 0 && isHighlighted;
                const isCollapsed = collapsedPaths.has(currentPath) && !forceExpand;
                
                const VERTICAL_SPACING = 80;
                const HORIZONTAL_SPACING = 240; 
                
                const nodesToRender = [];
                const linesToRender = [];

                // Rendu du Noeud
                nodesToRender.push(
                    <div 
                        key={currentPath}
                        className={`interactive-node absolute p-3 rounded-lg shadow-lg border transition-all duration-300 flex items-center justify-between gap-2 cursor-pointer
                            ${isDimmed ? 'opacity-30 grayscale blur-[1px]' : 'opacity-100'}
                            ${isHighlighted ? 'final-match' : 'border-slate-700 bg-slate-800'}
                            ${isLiveMatch ? 'live-match' : ''}
                            hover:scale-105 hover:z-50 hover:bg-slate-700
                        `}
                        style={{ 
                            left: x, 
                            top: y, 
                            width: '200px',
                            transform: 'translate(-50%, -50%)'
                        }}
                        onClick={(e) => {
                            if (node.type === 'file') setSelectedFile(node);
                            else toggleCollapse(e, currentPath);
                        }}
                    >
                        <div className="flex items-center gap-3 overflow-hidden">
                            <span className={node.type === 'folder' ? "text-yellow-400" : "text-blue-400"}>
                                {node.type === 'folder' ? <i data-lucide="folder" className="w-5 h-5"/> : <i data-lucide="file-text" className="w-5 h-5"/>}
                            </span>
                            <span className="truncate font-mono text-sm font-semibold select-none">{node.name}</span>
                        </div>
                        
                        {node.type === 'folder' && node.children && node.children.length > 0 && (
                            <button 
                                className={`text-slate-400 hover:text-white transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`}
                                onClick={(e) => toggleCollapse(e, currentPath)}
                            >
                                <i data-lucide="chevron-down" className="w-4 h-4"/>
                            </button>
                        )}
                    </div>
                );

                // Rendu des enfants
                if (node.children && node.children.length > 0 && !isCollapsed) {
                    const totalHeight = (node.children.length - 1) * VERTICAL_SPACING;
                    let startY = y - totalHeight / 2;

                    node.children.forEach((child, index) => {
                        const childX = x + HORIZONTAL_SPACING;
                        const childY = startY + (index * VERTICAL_SPACING);
                        const childPath = `${currentPath}/${child.name}`;
                        
                        // Une ligne est active UNIQUEMENT si l'enfant de destination est dans le chemin des résultats
                        // C'est ce qui fait que la ligne s'arrête exactement au dernier élément pertinent
                        const isLineActive = searchTerms.length > 0 && highlightedPaths.has(childPath);
                        
                        // Si une recherche est en cours mais que ce n'est pas le chemin, on cache presque la ligne
                        const isLineDimmed = searchTerms.length > 0 && !isLineActive;

                        linesToRender.push(
                            <svg key={`line-${currentPath}-${index}`} className="absolute top-0 left-0 w-full h-full pointer-events-none overflow-visible">
                                <path 
                                    d={`M ${x + 100} ${y} C ${x + 180} ${y}, ${childX - 120} ${childY}, ${childX - 100} ${childY}`}
                                    className={`node-line ${isLineActive ? 'active' : ''}`}
                                    style={{ opacity: isLineDimmed ? 0.05 : 1 }}
                                />
                            </svg>
                        );

                        const { nodes, lines } = renderTree(child, childX, childY, level + 1, currentPath);
                        nodesToRender.push(...nodes);
                        linesToRender.push(...lines);
                    });
                }

                return { nodes: nodesToRender, lines: linesToRender };
            };

            const treeElements = useMemo(() => renderTree(data, 150, window.innerHeight / 2, 0), [data, searchTerms, highlightedPaths, collapsedPaths, inputValue]);

            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            });

            return (
                <div className="w-full h-screen relative bg-slate-900 overflow-hidden font-sans">
                    
                    {/* --- HEADER --- */}
                    <div className="fixed top-0 left-0 w-full z-50 p-4 pointer-events-none flex justify-center">
                        <div className="glass-panel rounded-xl shadow-2xl p-2 w-full max-w-2xl pointer-events-auto flex flex-col gap-2">
                            <div className="flex items-center gap-2 bg-slate-900/80 rounded-lg border border-slate-700 px-3 py-2 transition-colors focus-within:border-blue-500">
                                <i data-lucide="search" className={`w-5 h-5 transition-colors ${inputValue ? 'text-yellow-400' : 'text-slate-400'}`}></i>
                                
                                <div className="flex gap-2 flex-wrap">
                                    {searchTerms.map((term, idx) => (
                                        <span key={idx} className="bg-blue-600 text-xs font-bold px-2 py-1 rounded flex items-center gap-1 animate-in fade-in zoom-in">
                                            {term}
                                            <button onClick={() => removeTag(idx)} className="hover:text-blue-200">×</button>
                                        </span>
                                    ))}
                                </div>

                                <input 
                                    type="text" 
                                    className="bg-transparent border-none outline-none text-white flex-1 min-w-[120px]"
                                    placeholder={searchTerms.length === 0 ? "Rechercher (ex: wordpress, ssh)..." : ""}
                                    value={inputValue}
                                    onChange={(e) => setInputValue(e.target.value)}
                                    onKeyDown={handleKeyDown}
                                />
                            </div>
                            
                            <div className="flex justify-between text-xs px-2 h-4">
                                <span className="text-slate-500">
                                    {inputValue && <span className="text-yellow-500 font-bold animate-pulse">Recherche instantanée...</span>}
                                </span>
                                {searchTerms.length > 0 && (
                                    <span className="text-slate-400 cursor-pointer hover:text-red-400 transition-colors" onClick={() => setSearchTerms([])}>
                                        Effacer tout
                                    </span>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* --- CANVAS --- */}
                    <div 
                        className="canvas-container w-full h-full relative"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        style={{
                            backgroundImage: 'radial-gradient(#334155 1px, transparent 1px)',
                            backgroundSize: '40px 40px'
                        }}
                    >
                        <div 
                            className="absolute origin-top-left transition-transform duration-75 ease-out"
                            style={{ 
                                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`
                            }}
                        >
                            {treeElements.lines}
                            {treeElements.nodes}
                        </div>
                    </div>

                    {/* --- PREVIEW MODAL --- */}
                    {selectedFile && (
                        <div className="fixed right-0 top-0 h-full w-1/3 min-w-[450px] glass-panel border-l border-slate-600 shadow-2xl animate-in slide-in-from-right duration-300 z-50 flex flex-col">
                            <div className="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                                <div className="flex flex-col overflow-hidden">
                                    <h2 className="text-lg font-bold text-blue-400 truncate flex items-center gap-2">
                                        <i data-lucide="file-code" className="w-5 h-5"/>
                                        {selectedFile.name}
                                    </h2>
                                    <span className="text-xs text-slate-500 truncate">{selectedFile.path}</span>
                                </div>
                                <button onClick={() => setSelectedFile(null)} className="p-2 hover:bg-red-500/20 hover:text-red-400 rounded-lg transition-colors">
                                    <i data-lucide="x" className="w-5 h-5"/>
                                </button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-6 bg-slate-900/50">
                                <div className="prose prose-invert prose-sm max-w-none">
                                    <pre className="whitespace-pre-wrap font-mono text-slate-300 text-sm">
                                        {selectedFile.content || "Contenu non disponible ou fichier vide."}
                                    </pre>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TreeCanvas />);
    </script>
</body>
</html>